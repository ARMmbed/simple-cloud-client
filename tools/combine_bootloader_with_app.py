#!/usr/bin/env python

from os import path
import hashlib, zlib, struct
import time

'''
define FIRMWARE_HEADER_MAGIC   0x5a51b3d4UL
define FIRMWARE_HEADER_VERSION 2
typedef struct _arm_uc_internal_header_t
{
    /* Metadata-header specific magic code */
    uint32_t headerMagic;

    /* Revision number for metadata header. */
    uint32_t headerVersion;

    /* Version number accompanying the firmware. Larger numbers imply more
       recent and preferred versions. This is used for determining the
       selection order when multiple versions are available. For downloaded
       firmware the manifest timestamp is used as the firmware version.
    */
    uint64_t firmwareVersion;

    /* Total space (in bytes) occupied by the firmware BLOB. */
    uint64_t firmwareSize;

    /* Firmware hash calculated over the firmware size. Should match the hash
       generated by standard command line tools, e.g., shasum on Linux/Mac.
    */
    uint8_t firmwareHash[ARM_UC_METADATA_SIZEOF_SHA512];

    /* The ID for the update campaign that resulted in the firmware update.
    */
    uint8_t campaign[ARM_UC_METADATA_SIZEOF_GUID];

    /* Header 32 bit CRC. Calculated over the entire header, including the CRC
       field, but with the CRC set to zero.
    */
    uint32_t headerCRC;
} arm_uc_internal_header_t;
'''

# define defaults to go into the metadata header
SIZEOF_SHA512     = 512/8
SIZEOF_GUID       = 128/8
SIZEOF_AES256_KEY = 256/8
SIZEOF_AES_BLOCK  = 128/8
FIRMWARE_HEADER_MAGIC = 0x5a51b3d4
FIRMWARE_HEADER_VERSION = 2
header_format = ">2I2Q{}s{}s2I".format(SIZEOF_SHA512, SIZEOF_GUID)

def create_header(app_blob, firmwareVersion):
    # calculate the hash of the application
    firmwareHash = hashlib.sha256(app_blob)

    # calculate the total size which is defined as the application size + metadata header
    firmwareSize = len(app_blob)

    # set campaign GUID to 0
    campaign = b'\00'

    # signature not supported, set size to 0
    signatureSize = 0

    print ('imageSize:    {}'.format(firmwareSize))
    print ('imageHash:    {}'.format(''.join(['{:0>2x}'.format(ord(c)) for c in firmwareHash.digest()])))
    print ('imageversion: {}'.format(firmwareVersion))

    # construct struct for CRC calculation
    headerCRC = 0
    FirmwareHeader = struct.pack(header_format,
                                 FIRMWARE_HEADER_MAGIC,
                                 FIRMWARE_HEADER_VERSION,
                                 firmwareVersion,
                                 firmwareSize,
                                 firmwareHash.digest(),
                                 campaign,
                                 signatureSize,
                                 headerCRC)

    # calculate checksum over header, including signatureSize but without headerCRC
    headerCRC = zlib.crc32(FirmwareHeader[:-4]) & 0xffffffff

    # Pack the data into a binary blob
    FirmwareHeader = struct.pack(header_format,
                                 FIRMWARE_HEADER_MAGIC,
                                 FIRMWARE_HEADER_VERSION,
                                 firmwareVersion,
                                 firmwareSize,
                                 firmwareHash.digest(),
                                 campaign,
                                 signatureSize,
                                 headerCRC)

    return FirmwareHeader


def combine(bootloader_blob, app_blob, app_offset, hdr_offset, output, version):

    # create header to go with the application binary
    FirmwareHeader = create_header(app_blob, version)

    # write the bootloader first
    offset = 0
    output.write(bootloader_blob)
    offset += len(bootloader_blob)

    # write the padding between bootloader and firmware header
    output.write(b'\00' * (hdr_offset - offset))
    offset += (hdr_offset - offset)

    # write firmware header
    output.write(FirmwareHeader)
    offset += len(FirmwareHeader)

    # write padding between header and application
    output.write(b'\00' * (app_offset - offset))

    # write the application
    output.write(app_blob)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(
        description='Combine bootloader with application adding metadata header.')

    def offset_arg(s):
        if s.startswith('0x'):
            return int(s, 16)
        else:
            return int(s)

    # specify arguments
    parser.add_argument('-b', '--bootloader',    type=argparse.FileType('rb'), required=True,
                        help='path to the bootloader binary')
    parser.add_argument('-a', '--app',           type=argparse.FileType('rb'), required=True,
                        help='path to application binary')
    parser.add_argument('-c', '--app-offset',    type=offset_arg,              required=True,
                        help='offset of the application')
    parser.add_argument('-d', '--header-offset', type=offset_arg,              required=True,
                        help='offset of the firmware metadata header')
    parser.add_argument('-o', '--output',        type=argparse.FileType('wb'), required=True,
                        help='output combined file path')
    parser.add_argument('-s', '--set-version',   type=int,                     required=False,
                        help='set version number', default=int(time.time()))

    # workaround for http://bugs.python.org/issue9694
    parser._optionals.title = "arguments"

    # get and validate arguments
    args = parser.parse_args()

    # read the contents of bootloader and application binaries into buffers
    bootloader_blob = args.bootloader.read()
    args.bootloader.close()
    app_blob = args.app.read()
    args.app.close()

    # combine applicaiton and bootloader adding metadata info
    combine(bootloader_blob, app_blob, args.app_offset, args.header_offset, args.output, args.set_version)

    # close output file
    output_fn = path.abspath(args.output.name)
    args.output.close()

    # print the output file path
    print 'Combined binary:', output_fn
